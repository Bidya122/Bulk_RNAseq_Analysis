---
title: "DESeq2_tutorial_GSE106305"
author: "Bidya Rani Mohanty"
date: "2025-10-07"
output: html_document
---
---------------------------------------------------------------------------------------
## Make sure the you are using latest version - R-4.5.1
# Check working version by 
version    #or
R.version.string    #Download the latest version - https://cran.r-project.org/bin/windows/base/
---------------------------------------------------------------------------------------

# Understand this chunk to install any package
```{r}
getwd()
setwd("C:\\Users\\HP\\Desktop\\bulk_rna_seq")  # to set path
install.packages("BiocManager") 
BiocManager::install(version = "3.22", ask = FALSE, update = FALSE, force = TRUE)
BiocManager::install(
  c("DESeq2", "SummarizedExperiment", "GenomicRanges", 
    "IRanges", "S4Vectors", "MatrixGenerics"),
  ask = FALSE,
  update = TRUE
)
##download rtools from https://cran.r-project.org/
BiocManager::install("GenomicRanges", version = "3.22", ask = FALSE, force = TRUE)
BiocManager::install("SummarizedExperiment", version = "3.22", ask = FALSE, force = TRUE)
BiocManager::install("DESeq2", version = "3.22", ask = FALSE, update = TRUE)
library(DESeq2)
install.packages("tidyverse")
library(tidyverse)
library(dplyr)
library(tibble)

# install.packages("pak")   # in case nothing works
# pak::pak("bioc::DESeq2")

#Let's get started
```


## preparing counts and metadata
```{r setup, include=FALSE}

raw_counts <- read.csv("GSE106305_counts_matrix.csv", header = TRUE, row.names = "Geneid", stringsAsFactors = FALSE)
head(raw_counts)
raw_counts <- raw_counts[,sort(colnames(raw_counts))]
colSums(raw_counts)

condition <- c(rep("LNCAP_Hypoxia", 2), rep("LNCAP_Normoxia", 2), rep("PC3_Hypoxia", 2), rep("PC3_Normoxia", 2))
print(condition)

my_colData <- as.data.frame(condition)
rownames(my_colData) <- colnames(raw_counts)
head(my_colData)
```


##  creating dds object
```{r}
dds <- DESeqDataSetFromMatrix(countData = raw_counts,
                              colData = my_colData,
                              design = ~condition)
dds
head(counts(dds))
dim(counts(dds))
```

```{r}
count_matrix <- counts(dds)
dim(count_matrix)
zero_counts_per_gene <- rowSums(count_matrix == 0)
count_matrix <- as.data.frame(count_matrix)
zero_summary <- table(zero_counts_per_gene)
print(zero_summary)
```


```{r}
install.packages("data.table")
library(data.table)
annotation_file <- "GRCh38annotation.csv"
annotation <- fread(annotation_file, stringsAsFactors = FALSE)
counts_gse <- read.csv("GSE106305_counts_matrix.csv",
                     header = TRUE,
                     stringsAsFactors = FALSE)

counts_gse$Geneid <- sub("\\..*$", "", counts_gse$Geneid)
annotation$Geneid <- sub("\\..*$", "", annotation$Geneid)
annotated_counts <- left_join(counts_gse, annotation, by = "Geneid") %>%
  select(Geneid, Genesymbol, Genebiotype, 
         LNCAP_Hypoxia_S1, LNCAP_Hypoxia_S2, LNCAP_Normoxia_S1, LNCAP_Normoxia_S2, 
         PC3_Hypoxia_S1, PC3_Hypoxia_S2, PC3_Normoxia_S1, PC3_Normoxia_S2)
```


```{r}
#Two step filtering
biotypes_to_keep <- c("protein_coding", "IG_J_gene", "IG_V_gene", "IG_C_gene", "IG_D_gene", "TR_D_gene", "TR_C_gene", "TR_V_gene", "TR_J_gene") ##gene biotypes I want to keep  

filtered_counts <- annotated_counts %>%
  filter(Genebiotype %in% biotypes_to_keep)  ##keeps only rows that matches the biotypes above

filtered_counts$Geneid <- sub("\\..*$", "", filtered_counts$Geneid)
head(filtered_counts, n = 3)  ##Strips Ensembl version suffixes from Geneid again, just in case!!

output_file <- "9biotype_count_matrix.csv"  ##Saves the filtered count matrix (only chosen biotypes) to a CSV file
fwrite(filtered_counts, file = output_file, sep = ",", row.names = FALSE)
zero_counts1 <- rowSums(filtered_counts[, 4:11] == 0)  ##Counts how many samples have zero counts per gene.
zero_summary2 <- table(zero_counts1)
print(zero_summary2) 

############## filtering 2nd step
keep_genes <- zero_counts1 < 7  ##Keeps genes that have counts in at least one sample (i.e., less than 7 zeros across 7 samples)
filtered_counts_nozero <- filtered_counts[keep_genes, ]   
cat("Number of genes after filtering (zeros in <7 samples):", nrow(filtered_counts_nozero), "\n")

new_zero_counts <- rowSums(filtered_counts_nozero[, 4:11] == 0)  ##Recalculates zero count summary after filtering.
cat("New zero counts distribution:\n")
print(table(new_zero_counts))

output_file <- "filtered_biotype_nozero_count_matrix.csv"  ##Exports the dataset after both filters: biotype and zero counts.
fwrite(filtered_counts_nozero, file = output_file, sep = ",", row.names = FALSE)

head(filtered_counts_nozero, n = 3)

dds_filtered <- dds[rownames(dds) %in% filtered_counts_nozero$gene_id, ]  ##Keeps only rows (genes) in the original DESeq2 object dds that passed filters. rownames(dds) are gene IDs.

cat("Dimensions of filtered DESeqDataSet:", dim(dds_filtered), "\n")

removed_genes <- filtered_counts[!keep_genes, ]  ## Get genes filtered out due to zeros in all samples
cat("Biotype distribution of removed genes:\n")
removed_biotype_dist <- table(removed_genes$Genebiotype)
print(removed_biotype_dist)
```


```{r}
print(colnames(filtered_counts)) ##outputs the column names of filtered_counts data frame.
zero_counts <- rowSums(filtered_counts[, 4:11] == 0) ##For each gene(each row), counts how many samples(columns 4 to 11) have a zero count.
zero_summary <- table(zero_counts)
print(zero_summary)
keep_genes <- zero_counts < 7
filtered_counts_nozero <- filtered_counts[keep_genes, ]  ##Keeps genes expressed(non-zero) in at least 2 samples(since fewer than 7 zeros).
cat("Number of genes after filtering (zeros in <7 samples):", nrow(filtered_counts_nozero), "\n")

# Count zeros again in the filtered dataset to check the new distribution
new_zero_counts <- rowSums(filtered_counts_nozero[, 4:11] == 0)
print(table(new_zero_counts))

# Save the filtered count matrix to a CSV file
output_file <- "filtered_biotype_6.csv"
fwrite(filtered_counts_nozero, file = output_file, sep = ",", row.names = FALSE)

# Preview first 3 rows
head(filtered_counts_nozero, n = 3)

# Filter the original DESeq2 dataset (dds) to keep only genes that passed the zero-count filtering
dds_filtered <- dds[rownames(dds) %in% filtered_counts_nozero$Geneid, ]

```

```{r}
biotype_counts <- filtered_counts_nozero %>%  ##Using the zero-count-cleaned dataset (filtered_counts_nozero), it counts how many genes belong to each gene biotype (Genebiotype). Then it calculates the proportion and percentage of each biotype relative to the total genes.
  count(Genebiotype) %>%
  mutate(Proportion = n / sum(n),
         Percentage = Proportion * 100) %>%
  rename(Biotype = Genebiotype)  # Rename for clarity in plot
print(biotype_counts)

p <- ggplot(biotype_counts, aes(x = reorder(Biotype, -Proportion), y = Proportion, fill = Biotype)) +    ##create plot with ggplo2
    geom_bar(stat = "identity") +
    labs(title = "Proportion of Genes by Biotype",
        x = "Gene Biotypes",
          y = "Proportion") +
     scale_y_continuous(labels = scales::percent_format(scale = 100)) +  # Show proportions as percentages
    theme_minimal() +
     theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Legend is shown now
    scale_fill_brewer(palette = "Set2")  # Use distinct colors 
p
output_plot <- "genebiotype_proportions1.png"
ggsave(output_plot, plot = p, width = 8, height = 6, dpi = 300)
```



```{r}
vsd <- vst(dds_filtered, blind = TRUE)  # blind=TRUE for exploratory PCA  ##transforms the filtered DESeq2 data for variance stabilization, which is good for PCA  
##Variance Stabilizing Transformation
plot_PCA = function (vsd.obj) {
  pcaData <- plotPCA(vsd.obj,  intgroup = c("condition"), returnData = T)
  percentVar <- round(100 * attr(pcaData, "percentVar"))
  ggplot(pcaData, aes(PC1, PC2, color=condition)) +
    geom_point(size=3) +
    labs(x = paste0("PC1: ",percentVar[1],"% variance"),
         y = paste0("PC2: ",percentVar[2],"% variance"),
         title = "PCA Plot colored by condition") +
    ggrepel::geom_text_repel(aes(label = name), color = "black")
}

png(filename = "pcab.png", 
    width = 2000, height = 2000, res = 300)  # adjust width/height as needed
plot_PCA(vsd)
dev.off()
##using ntop=500 top features by variance  ##selecting the 500 genes (features) with the highest variability across samples
```


```{r}
dds <- DESeq(dds_filtered)
dds
normalized_counts <- counts(dds, normalized = T)
normalized_counts_df <- as.data.frame(normalized_counts)
write.csv(normalized_counts_df, file = "normalized_counts.csv", row.names = TRUE)
```


```{r}
vsd <- vst(dds, blind = TRUE)  # blind=TRUE for exploratory PCA
plot_PCA = function (vsd.obj) {
  pcaData <- plotPCA(vsd.obj,  intgroup = c("condition"), returnData = T)
  percentVar <- round(100 * attr(pcaData, "percentVar"))
  ggplot(pcaData, aes(PC1, PC2, color=condition)) +
    geom_point(size=3) +
    labs(x = paste0("PC1: ",percentVar[1],"% variance"),
         y = paste0("PC2: ",percentVar[2],"% variance"),
         title = "PCA Plot colored by condition") +
    ggrepel::geom_text_repel(aes(label = name), color = "black")
}

png(filename = "pcaa.png", 
    width = 2000, height = 2000, res = 300)  # adjust width/height as needed
plot_PCA(vsd)
dev.off()


vsd <- vst(dds, blind = TRUE)
plotDists = function (vsd.obj) {
  sampleDists <- dist(t(assay(vsd.obj)))
  sampleDistMatrix <- as.matrix(sampleDists)
  rownames(sampleDistMatrix) <- paste(vsd.obj$condition)
  colors <- colorRampPalette(rev(RColorBrewer::brewer.pal(9, "Blues")))(55)
  pheatmap::pheatmap(sampleDistMatrix, clustering_distance_rows = sampleDists,  clustering_distance_cols = sampleDists, col = colors, fontsize_row = 4, fontsize_col = 4, fontsize_legend = 4, fontsize = 4)
}
png(filename = "sampleheatmap1.png", width = 1000, height = 900, res = 300)  # adjust width/height as needed
plotDists(vsd)
dev.off()

variable_gene_heatmap <- function (vsd.obj, num_genes = 500, annotation, title = "") {
  brewer_palette <- "RdBu"
  ramp <- colorRampPalette( RColorBrewer::brewer.pal(11, brewer_palette))
  mr <- ramp(256)[256:1]
  stabilized_counts <- assay(vsd.obj)
  row_variances <- rowVars(stabilized_counts)
  top_variable_genes <- stabilized_counts[order(row_variances, decreasing=T)[1:num_genes],]
  top_variable_genes <- top_variable_genes - rowMeans(top_variable_genes, na.rm=T)
  gene_names <- annotation$Gene.name[match(rownames(top_variable_genes), annotation$Gene.stable.ID)]
  rownames(top_variable_genes) <- gene_names
  coldata <- as.data.frame(vsd.obj@colData)
  coldata$sizeFactor <- NULL
  pheatmap::pheatmap(top_variable_genes, color = mr, annotation_col = coldata, fontsize_col = 8, fontsize_row = 250/num_genes, border_color = NA, main = title)
}

png(filename = "variable_gene_heatmap.png", 
    width = 1000, height = 1000, res = 300)  # adjust width/height as needed
variable_gene_heatmap(vsd, num_genes = 40, annotation = annotation)
dev.off()

dim(dds)
```

```{r}
library(DESeq2)
library(tidyverse)

# Subset LNCAP samples
dds_lncap <- dds[, grepl("LNCAP", colnames(dds))]

# Drop unused factor levels
dds_lncap$condition <- droplevels(dds_lncap$condition)

# Set reference level
dds_lncap$condition <- relevel(dds_lncap$condition, ref = "LNCAP_Normoxia")

# Run DESeq2
dds_lncap <- DESeq(dds_lncap)

# Get results for Hypoxia vs Normoxia
res_lncap <- results(dds_lncap, contrast = c("condition", "LNCAP_Hypoxia", "LNCAP_Normoxia"))

# Order by adjusted p-value
reslncapOrdered <- res_lncap[order(res_lncap$padj), ]

# Count significant genes (FDR < 0.05)
sum(reslncapOrdered$padj < 0.05, na.rm = TRUE)

# Quick look at top DEGs
head(reslncapOrdered)

# Summary
summary(reslncapOrdered)

# Save results to CSV
write.csv(as.data.frame(reslncapOrdered), file = "DEGs_lncap.csv")
library(org.Hs.eg.db)
library(AnnotationDbi)

# Get gene symbols for ENSEMBL IDs
gene_symbols <- mapIds(org.Hs.eg.db,
                       keys = rownames(reslncapOrdered),
                       column = "SYMBOL",
                       keytype = "ENSEMBL",
                       multiVals = "first")

# Add gene symbols to results
reslncapOrdered$gene <- gene_symbols

# View top DEGs with gene names
head(reslncapOrdered)
write.csv(as.data.frame(reslncapOrdered), file = "DEGs_lncap_with_genes.csv", row.names = TRUE)


```


```{r}
plotMA(res_lncap, main = "MA-plot: LNCAP Hypoxia vs Normoxia", ylim = c(-5, 5))
png("MA_plot_LNCAP.png", width = 1200, height = 1000, res = 150)  # open PNG device
plotMA(res_lncap, main = "MA-plot: LNCAP Hypoxia vs Normoxia", ylim = c(-5, 5))
dev.off()
```


```{r}
# Convert DESeq2 results to a standard data frame
res_df <- as.data.frame(reslncapOrdered)

# Remove rows with NA values (if any)
res_df <- na.omit(res_df)

# Add a column for gene names using rownames
res_df$gene <- rownames(res_df)

# Initialize a column to categorize regulation status
res_df$regulation <- "Not Significant"

# Mark genes as "Upregulated" if padj < 0.05 and log2FC > 1
res_df$regulation[res_df$padj < 0.05 & res_df$log2FoldChange > 1] <- "Upregulated"

# Mark genes as "Downregulated" if padj < 0.05 and log2FC < -1
res_df$regulation[res_df$padj < 0.05 & res_df$log2FoldChange < -1] <- "Downregulated"

# Create a volcano plot with ggplot2
qp <- ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj), color = regulation)) +
  geom_point(alpha = 0.6) +  # Plot points with semi-transparency
  scale_color_manual(values = c("Upregulated" = "#FEA405",  # Orange for upregulated
                                "Downregulated" = "purple", # Purple for downregulated
                                "Not Significant" = "gray")) + # Gray for non-significant genes
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") + # Horizontal line for padj = 0.05 threshold
  annotate("text", x = min(res_df$log2FoldChange), y = -log10(0.05) + 0.5,
           label = "padj = 0.05", hjust = 0, size = 3) +  # Label the significance threshold
  theme_minimal() +  # Minimal theme for a clean plot
  labs(title = "Volcano Plot", 
       x = "Log2 Fold Change", 
       y = "-Log10 Adjusted P-Value") +  # Axis labels and title
  theme(plot.title = element_text(hjust = 0.5))  # Center the plot title

# Define filename for saving the plot
v_plot <- "vp_lncap.png"

# Save the volcano plot as a PNG with specified size and resolution
ggsave(v_plot, plot = qp, width = 8, height = 6, dpi = 300)

```

# not to be used
```{r}
# ================================
# Heatmap of top DEGs for LNCAP
# ================================

library(DESeq2)
library(dplyr)
library(pheatmap)
library(RColorBrewer)
library(data.table)

# --- Parameters ---
padj_cutoff <- 0.001
ngenes <- 30
annotation_file <- "GRCh38annotation.csv"  # your annotation file

# --- Load annotation and counts ---
annotation <- fread(annotation_file, stringsAsFactors = FALSE)

# Ensure IDs are consistent (remove version numbers)
annotation$Geneid <- sub("\\..*$", "", annotation$Geneid)
normalized_counts <- counts(dds_lncap, normalized = TRUE)
rownames(normalized_counts) <- sub("\\..*$", "", rownames(normalized_counts))

# --- Map Gene IDs to Symbols ---
gene_map <- setNames(annotation$Genesymbol, annotation$Geneid)

# --- Order DEGs by adjusted p-value ---
reslncapOrdered <- res_lncap[order(res_lncap$padj), ]

# --- Select top significant genes ---
top_genes <- rownames(reslncapOrdered)[reslncapOrdered$padj < padj_cutoff][1:ngenes]
top_genes_clean <- sub("\\..*$", "", top_genes)  # remove versions if any

# --- Map to gene symbols and make unique ---
gene_labels <- gene_map[top_genes_clean]
gene_labels <- as.character(gene_labels)
gene_labels[is.na(gene_labels)] <- top_genes_clean[is.na(gene_labels)]
gene_labels <- make.unique(gene_labels)

# --- Subset normalized counts ---
top_counts <- normalized_counts[top_genes, ]

# --- Scale rows (z-score) ---
top_counts_scaled <- t(scale(t(top_counts)))
rownames(top_counts_scaled) <- gene_labels

# --- Color palette ---
brewer_palette <- "RdBu"
ramp <- colorRampPalette(RColorBrewer::brewer.pal(11, brewer_palette))
mr <- ramp(256)[256:1]  # reversed blue -> red

# --- Save heatmap as PNG ---
png("DEG_heatmap_LNCAP.png", width = 1200, height = 900, res = 150)
pheatmap(top_counts_scaled,
         color = mr,
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         fontsize_col = 10,
         fontsize_row = max(6, 200/ngenes),
         border_color = NA,
         main = paste("Top", ngenes, "DE Genes (padj <", padj_cutoff, ")"))
dev.off()


```



```{r}

# Extract raw counts from DESeq2 object
raw_counts <- assay(dds)  

# Extract variance-stabilized counts from VST object
vst_counts <- assay(vsd)  

# Open a PNG device to save the plots
# width, height in pixels; res = resolution in dpi
png("C:\\Users\\HP\\Desktop\\bulk_rna_seq\\density_plots_raw_vst.png",
    width = 4000, height = 4000, res = 300)  

# Set plotting layout: 4 rows x 4 columns of plots
# 'mar' sets margins: bottom, left, top, right
par(mfrow = c(4, 4), mar = c(3, 3, 2, 1))  

# Loop over the first 8 samples
for (i in 1:8) {
  # --- Plot density of raw counts for the i-th sample ---
  plot(density(raw_counts[, i]),
       main = paste("Raw - Sample", colnames(raw_counts)[i]),  # Title of the plot
       xlab = "Expression",  # Label x-axis
       col = "red",          # Red color for raw counts
       lwd = 2,              # Line width
       ylim = c(0, max(sapply(1:8, function(j) max(density(raw_counts[, j])$y, na.rm = TRUE))))
       # Set uniform y-axis across all raw counts plots
       )
  
  # --- Plot density of VST counts for the i-th sample ---
  plot(density(vst_counts[, i]),
       main = paste("VST - Sample", colnames(vst_counts)[i]),  # Title of the plot
       xlab = "Expression",  # Label x-axis
       col = "blue",         # Blue color for VST counts
       lwd = 2,              # Line width
       ylim = c(0, max(sapply(1:8, function(j) max(density(vst_counts[, j])$y, na.rm = TRUE))))
       # Set uniform y-axis across all VST plots
       )
}

# Close the PNG device and save the plots to file
dev.off()  

```


```{r}
res_lncap <- read.csv("DEGs_lncap.csv", row.names = 1)
head(res_lncap)
# Install BiocManager if not already installed
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

# Install clusterProfiler from Bioconductor
BiocManager::install("clusterProfiler", version = "3.22", ask = FALSE, update = TRUE)

# Load the package
library(clusterProfiler)
BiocManager::install("org.Hs.eg.db", version = "3.22", ask = FALSE, update = TRUE)
library(clusterProfiler)
library(org.Hs.eg.db)
library(dplyr)
library(stats)
BiocManager::install("ReactomePA", version = "3.22", ask = FALSE, update = TRUE)
library(ReactomePA)
ncbi_list <- clusterProfiler::bitr(
  geneID = rownames(res_lncap),        # use Ensembl IDs from row names
  fromType = "ENSEMBL",          
  toType = "ENTREZID", 
  OrgDb = org.Hs.eg.db
)

res_lncap$ENSEMBL <- rownames(res_lncap)

res_mapped <- res_lncap %>%
  left_join(ncbi_list, by = "ENSEMBL") %>%
  filter(!is.na(ENTREZID)) %>%
  distinct(ENTREZID, .keep_all = TRUE)

ngenes <- res_mapped$log2FoldChange
names(ngenes) <- res_mapped$ENTREZID
ngenes <- sort(ngenes, decreasing = TRUE)

library(ReactomePA)
enp_gsea <- gsePathway( ngenes, organism = "human", pvalueCutoff = 0.05, verbose = FALSE)
head(enp_gsea@result)
enp_gsea2 <- gsePathway(ngenes, organism = "human", pvalueCutoff = 0.05, pAdjustMethod = "BH", minGSSize = 10, maxGSSize = 500, verbose = FALSE)
# Save the GSEA result to CSV
gsea_result <- enp_gsea2@result

write.csv(gsea_result, file = "GSEA_Reactome_results.csv", row.names = FALSE)

```

```{r}
enp_gsea <- clusterProfiler::setReadable(enp_gsea, OrgDb = org.Hs.eg.db, keyType = "ENTREZID")

pathways <- enp_gsea@result
pathways <- pathways[order(pathways$p.adjust), ]  # Sort by FDR (adjusted p-value)
top_pathways <- pathways[order(abs(pathways$NES), decreasing = TRUE), ]  # Sort by NES

library(dplyr)
library(forcats)

top20 <- top_pathways[1:20, ] %>%
  mutate(Description = fct_reorder(Description, NES))  # Reorder factor for y-axis

write.csv(top20, "top20_pathways.csv", row.names = FALSE)

```

```{r}
library(ggplot2)

r1 <- ggplot(top20, aes(x = NES,
                        y = Description,
                        color = p.adjust,
                        size = setSize)) +
  geom_point(alpha = 0.9) +
  scale_color_gradient(low = "#0072B2", high = "#D55E00", name = "FDR (p.adjust)") +
  scale_size(range = c(3, 10), name = "Gene Set Size") +
  labs(
    title = "Top 10 Enriched Pathways",
    subtitle = "Gene Set Enrichment Analysis (GSEA)",
    x = "Normalized Enrichment Score (NES)",
    y = NULL,
    caption = "Data source: clusterProfiler::gsePathway"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(size = 12),
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 13),
    legend.position = "right"
  )
ggsave(
  filename = "Top10_GSEA_plot.png",  # file name
  plot = r1,                         # the ggplot object
  width = 10,                        # width in inches
  height = 6,                        # height in inches
  dpi = 300                           # resolution
)
r1
```


```{r}
library(ReactomePA)
sig_genes <- res_mapped %>%
  filter(padj < 0.1, abs(log2FoldChange) > 0.5) %>%
  pull(ENTREZID)
enr <- enrichPathway(gene = sig_genes, organism = "human", pvalueCutoff = 0.1)
dotplot(enr, showCategory=20)
dp <- dotplot(enr, showCategory = 20)
ggsave(
  filename = "ReactomePA_dotplot.png",
  plot = dp,
  width = 10,
  height = 6,
  dpi = 300
)

```


```{r}
# Define a function to plot expression of a specific gene from a DESeq2 object
plot_counts <- function (dds, gene, normalization = "DESeq2"){
  
  # Load gene annotation file that maps Ensembl IDs to gene symbols
  annotation <- read.csv("GRCh38annotation.csv", header = T, stringsAsFactors = F)
  
  # Choose normalization method
  if (normalization == "cpm") {
    # Counts per million (CPM) normalization
    normalized_data <- cpm(counts(dds, normalized = F)) 
  } else if (normalization == "DESeq2")
    # Use DESeq2 normalized counts
    normalized_data <- counts(dds, normalized = T) 
  
  # Extract sample condition information from DESeq2 object
  condition <- dds@colData$condition
  
  # Determine the Ensembl ID for the gene input
  if (is.numeric(gene)) { 
    # If numeric input, treat as row index
    if (gene%%1==0 )
      ensembl_id <- rownames(normalized_data)[gene]
    else
      stop("Invalid index supplied.")
  } else if (gene %in% annotation$Genesymbol){ 
    # If input is a gene symbol, map to Ensembl ID
    ensembl_id <- annotation$Geneid[which(annotation$Genesymbol == gene)]
  } else if (gene %in% annotation$Geneid){
    # If input is already Ensembl ID, use as-is
    ensembl_id <- gene
  } else {
    # Stop if gene cannot be found
    stop("Gene not found. Check spelling.")
  }
  
  # Extract normalized expression values for the gene
  expression <- normalized_data[ensembl_id,]
  
  # Get the gene symbol corresponding to the Ensembl ID
  gene_name <- annotation$Genesymbol[which(annotation$Geneid == ensembl_id)]
  
  # Combine expression and condition into a tidy tibble for plotting
  gene_tib <- tibble(condition = condition, expression = expression)
  
  # Create a boxplot of gene expression across conditions
  ggplot(gene_tib, aes(x = condition, y = expression))+
    geom_boxplot(outlier.size = NULL)+    # Boxplot of expression
    geom_point()+                         # Overlay individual points
    labs (
      title = paste0("Expression of ", gene_name, " - ", ensembl_id),  # Plot title
      x = "group", 
      y = paste0("Normalized expression (", normalization , ")")        # Y-axis label
    )+
    theme(
      axis.text.x = element_text(size = 11), 
      axis.text.y = element_text(size = 11)                               # Axis text size
    )
}

# Plot expression of the gene "IGFBP1"
plot_counts(dds, "IGFBP1")

# Assign the plot to a variable for saving
p <- plot_counts(dds, "IGFBP1")

# Save the plot as a high-resolution PNG
ggsave(
  filename = "IGFBP1_expression_plot.png",  # File name
  plot = p,                                 # ggplot object
  width = 6,                                # Width in inches
  height = 5,                               # Height in inches
  dpi = 300                                 # Resolution
)
```








```{r}

library(fgsea)
hallmark_pathway <- gmtPathways("h.all.v7.0.symbols.gmt.txt")
head(names(hallmark_pathway))
head(hallmark_pathway$HALLMARK_HYPOXIA, 20)
# Make sure you have your DESeq2 results
res <- results(dds)

# remove NA values
rnk_df <- res_lncap[!is.na(res_lncap$log2FoldChange), ]

# create a two-column ranked list
rnk <- data.frame(
  Gene = rownames(rnk_df),
  Score = rnk_df$log2FoldChange
)

# save as tab-delimited .rnk file
write.table(rnk, "lncaprank.rnk", sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)


lncap_ranked_list <- read.table("lncaprank.rnk", header = T, stringsAsFactors = F)
head(lncap_ranked_list)
prepare_ranked_list <- function(ranked_list) { 
  if( sum(duplicated(ranked_list$Gene.name)) > 0) {
    ranked_list <- aggregate(.~Gene.name, FUN = mean, data = ranked_list)
    ranked_list <- ranked_list[order(ranked_list$log2FoldChange, decreasing = T),]
  }
  ranked_list <- na.omit(ranked_list)
  ranked_list <- tibble::deframe(ranked_list)
  ranked_list
}

lncap_ranked_list <- prepare_ranked_list(lncap_ranked_list)
head(lncap_ranked_list)
```


```{r}
# Define a function to prepare a ranked gene list for GSEA
prepare_ranked_list <- function(ranked_list) {
  
  # If input is already a vector (not a list), return it as-is
  if (is.vector(ranked_list) && !is.list(ranked_list)) {
    return(ranked_list)
  }

  # Stop execution if input is not a data frame
  if (!is.data.frame(ranked_list)) {
    stop("Input 'ranked_list' must be a data frame with 'Gene.name' and 'log2FoldChange' columns.")
  }

  # Handle duplicate gene entries by averaging their values
  if (sum(duplicated(ranked_list$Gene.name)) > 0) {
    ranked_list <- aggregate(. ~ Gene.name, data = ranked_list, FUN = mean)
    # Order the genes by decreasing log2 fold change
    ranked_list <- ranked_list[order(ranked_list$log2FoldChange, decreasing = TRUE), ]
  }

  # Remove any NA values from the ranked list
  ranked_list <- na.omit(ranked_list)

  # Convert the data frame to a named vector (gene names as names, log2FC as values)
  ranked_list <- tibble::deframe(ranked_list[, c("Gene.name", "log2FoldChange")])

  # Return the processed ranked list
  return(ranked_list)
}

# If 'lncap_ranked_list' does not exist, create it from DESeq2 results
if (!exists("lncap_ranked_list")) {
  # Convert DESeq2 results to a data frame and select relevant columns
  lncap_ranked_list <- as.data.frame(res_lncap) %>%
    dplyr::select(Gene.name = gene_symbol, log2FoldChange)  # Adjust column names as needed
}

# Apply the function to prepare a ranked gene vector for GSEA
lncap_ranked_list <- prepare_ranked_list(lncap_ranked_list)

# Print the top entries of the ranked list to inspect
print(head(lncap_ranked_list))

```
```{r}
# Load required libraries
library(clusterProfiler)
library(org.Hs.eg.db)
library(fgsea)
library(ggplot2)
library(dplyr)

# --------------------------------------------
# STEP 1: Prepare ranked list
# --------------------------------------------
# Assuming 'res_lncap' is your DESeq2 results table with log2FoldChange
rnk_df <- res_lncap[!is.na(res_lncap$log2FoldChange), ]
ngenes <- rnk_df$log2FoldChange
names(ngenes) <- rownames(rnk_df)

# Convert Ensembl IDs to gene symbols
lncap_symbols <- bitr(
  names(ngenes),
  fromType = "ENSEMBL",
  toType = "SYMBOL",
  OrgDb = org.Hs.eg.db
)

# Merge Ensembl and SYMBOL mappings
ngenes <- ngenes[lncap_symbols$ENSEMBL]
names(ngenes) <- lncap_symbols$SYMBOL

# Clean ranked list (remove NAs, duplicates, sort decreasing)
ngenes <- ngenes[!is.na(names(ngenes))]
ngenes <- ngenes[!duplicated(names(ngenes))]
ngenes <- sort(ngenes, decreasing = TRUE)

# --------------------------------------------
# STEP 2: Load Hallmark pathways
# --------------------------------------------
gmt_file <- "h.all.v7.0.symbols.gmt"

if (!file.exists(gmt_file)) {
  download.file(
    "https://data.broadinstitute.org/gsea-msigdb/msigdb/release/7.0/h.all.v7.0.symbols.gmt",
    destfile = gmt_file
  )
}

hallmark_pathways <- gmtPathways(gmt_file)

# --------------------------------------------
# STEP 3: Run fgsea
# --------------------------------------------
set.seed(123)  # for reproducibility
fgsea_res <- fgsea(
  pathways = hallmark_pathways,
  stats = ngenes,
  minSize = 15,
  maxSize = 500,
  nperm = 1000
)

# Order results by NES
fgsea_res_ordered <- fgsea_res[order(-fgsea_res$NES), ]
head(fgsea_res_ordered[, c("pathway", "padj", "NES")])

# --------------------------------------------
# STEP 4: Plot top pathways
# --------------------------------------------
# Top 10 enriched pathways
topPathways <- fgsea_res_ordered$pathway[1:10]

# Plot NES for top pathways
ggplot(fgsea_res_ordered %>% filter(pathway %in% topPathways),
       aes(x = reorder(pathway, NES), y = NES, fill = NES > 0)) +
  geom_col() +
  coord_flip() +
  scale_fill_manual(values = c("red", "blue"), guide = FALSE) +
  labs(title = "Top 10 Hallmark Pathways (fgsea)",
       x = "Pathway",
       y = "Normalized Enrichment Score (NES)") +
  theme_minimal()

# Optional: save plot
ggsave("fgsea_top10_pathways.png", width = 8, height = 6)


```


```{r}
library(ggplot2)
library(dplyr)
library(stringr)

waterfall_plot <- function(fgsea_results, graph_title, save_path = NULL) {
  p <- fgsea_results %>% 
    mutate(
      short_name = str_split_fixed(pathway, "_", 2)[,2],  # remove 'HALLMARK_'
      sig = padj < 0.05
    ) %>%
    ggplot(aes(x = reorder(short_name, NES), y = NES, fill = sig)) +
      geom_bar(stat = "identity") +
      coord_flip() +
      scale_fill_manual(values = c("TRUE" = "steelblue", "FALSE" = "grey70")) +
      labs(
        x = "Hallmark Pathway",
        y = "Normalized Enrichment Score (NES)",
        title = graph_title
      ) +
      theme_minimal() +
      theme(
        axis.text.y = element_text(size = 7),
        plot.title = element_text(hjust = 0.5)
      )
  
  # Save if path is provided
  if (!is.null(save_path)) {
    ggsave(filename = save_path, plot = p, width = 8, height = 6)
  }
  
  return(p)
}
waterfall_plot(
  fgsea_results = fgsea_res_ordered,
  graph_title = "Hallmark pathways altered by hypoxia in LNCaP cells",
  save_path = "fgsea_waterfall_plot.png"
)
```

